package com.nowar.tools;

import java.io.ByteArrayOutputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.OutputStream;

import android.content.res.Resources;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.graphics.Canvas;
import android.graphics.LinearGradient;
import android.graphics.Matrix;
import android.graphics.Paint;
import android.graphics.PixelFormat;
import android.graphics.Bitmap.CompressFormat;
import android.graphics.Bitmap.Config;
import android.graphics.PorterDuff.Mode;
import android.graphics.PorterDuffXfermode;
import android.graphics.Rect;
import android.graphics.RectF;
import android.graphics.Shader.TileMode;
import android.graphics.drawable.Drawable;

public class test_Bitmap {

	public static final Bitmap createRGBImage(Bitmap bitmap, int color) {
		int bitmap_w = bitmap.getWidth();
		int bitmap_h = bitmap.getHeight();
		System.out.println("bitmap_w:" + bitmap_w);
		System.out.println("bitmap_h:" + bitmap_h);
		int[] arrayColor = new int[bitmap_w * bitmap_h];
		int count = 0;
		for (int i = 0; i < bitmap_h; i++) {
			for (int j = 0; j < bitmap_w; j++) {
				int color1 = bitmap.getPixel(j, i);
				//System.out.println("i:" + i + "--color1--:" + color1);

				// 这里也可以取出 R G B 可以扩展一下 做更多的处理，
				// 暂时我只是要处理除了透明的颜色，改变其他的颜色
				if (color1 != 0) {
					color1 = color;
				} else {

				}
				arrayColor[count] = color1;
				count++;
			}
		}
		bitmap = Bitmap.createBitmap(arrayColor, bitmap_w, bitmap_h,
				Config.ARGB_8888);
		return bitmap;
	}

	public static Bitmap drawableToBitmap(Drawable drawable) {

		Bitmap bitmap = Bitmap

		.createBitmap(

		drawable.getIntrinsicWidth(),

		drawable.getIntrinsicHeight(),

		drawable.getOpacity() != PixelFormat.OPAQUE ? Bitmap.Config.ARGB_8888

		: Bitmap.Config.RGB_565);

		Canvas canvas = new Canvas(bitmap);

		// canvas.setBitmap(bitmap);

		drawable.setBounds(0, 0, drawable.getIntrinsicWidth(),

		drawable.getIntrinsicHeight());

		drawable.draw(canvas);

		return bitmap;

	}

	// 将Drawable转化为Bitmap

	public static Bitmap drawableToBitmap_2(Drawable drawable) {

		int width = drawable.getIntrinsicWidth();

		int height = drawable.getIntrinsicHeight();

		Bitmap bitmap = Bitmap.createBitmap(width, height,

		drawable.getOpacity() != PixelFormat.OPAQUE ? Bitmap.Config.ARGB_8888

		: Bitmap.Config.RGB_565);

		Canvas canvas = new Canvas(bitmap);

		drawable.setBounds(0, 0, width, height);

		drawable.draw(canvas);

		return bitmap;

	}

	// 2、从资源中获取Bitmap
	//
	// Resources res=getResources();
	//
	// Bitmap bmp=BitmapFactory.decodeResource(res, R.drawable.pic);

	public static Bitmap DrawableToBitmap(Resources res, int drawable) {
		Bitmap bmp = BitmapFactory.decodeResource(res, drawable);
		return bmp;
	}

	// 3、Bitmap → byte[]

	private byte[] Bitmap2Bytes(Bitmap bm) {

		ByteArrayOutputStream baos = new ByteArrayOutputStream();

		bm.compress(Bitmap.CompressFormat.PNG, 100, baos);

		return baos.toByteArray();

	}

	// 4、byte[] → Bitmap

	private Bitmap Bytes2Bimap(byte[] b) {

		if (b.length != 0) {

			return BitmapFactory.decodeByteArray(b, 0, b.length);

		}

		else {

			return null;

		}

	}

	// 5、保存bitmap

	static boolean saveBitmap2file(Bitmap bmp, String filename) {

		CompressFormat format = Bitmap.CompressFormat.JPEG;
		int quality = 100;
		OutputStream stream = null;
		try {
			stream = new FileOutputStream("/sdcard/" + filename);
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			// Generated by Foxit PDF Creator © Foxit Software
			// http://www.foxitsoftware.com For evaluation only.
			e.printStackTrace();
		}

		return bmp.compress(format, quality, stream);

	}

	// 获得圆角图片的方法

	public static Bitmap getRoundedCornerBitmap(Bitmap bitmap, float roundPx) {

		Bitmap output = Bitmap.createBitmap(bitmap.getWidth(), bitmap

		.getHeight(), Config.ARGB_8888);

		Canvas canvas = new Canvas(output);

		final int color = 0xff424242;

		final Paint paint = new Paint();

		final Rect rect = new Rect(0, 0, bitmap.getWidth(), bitmap.getHeight());

		final RectF rectF = new RectF(rect);

		paint.setAntiAlias(true);

		canvas.drawARGB(0, 0, 0, 0);

		paint.setColor(color);

		canvas.drawRoundRect(rectF, roundPx, roundPx, paint);
		paint.setXfermode(new PorterDuffXfermode(Mode.SRC_IN));
		canvas.drawBitmap(bitmap, rect, rect, paint);

		return output;

	}

	// 获得带倒影的图片方法

	public static Bitmap createReflectionImageWithOrigin(Bitmap bitmap) {

		final int reflectionGap = 4;

		int width = bitmap.getWidth();

		int height = bitmap.getHeight();

		Matrix matrix = new Matrix();

		matrix.preScale(1, -1);

		Bitmap reflectionImage = Bitmap.createBitmap(bitmap,

		0, height / 2, width, height / 2, matrix, false);

		Bitmap bitmapWithReflection = Bitmap.createBitmap(width,
				(height + height / 2),

				Config.ARGB_8888);

		Canvas canvas = new Canvas(bitmapWithReflection);

		canvas.drawBitmap(bitmap, 0, 0, null);

		Paint deafalutPaint = new Paint();

		// Generated by Foxit PDF Creator © Foxit Software

		// http://www.foxitsoftware.com For evaluation only.

		canvas.drawRect(0, height, width, height + reflectionGap,

		deafalutPaint);

		canvas.drawBitmap(reflectionImage, 0, height + reflectionGap, null);

		Paint paint = new Paint();

		LinearGradient shader = new LinearGradient(0,

		bitmap.getHeight(), 0, bitmapWithReflection.getHeight()

		+ reflectionGap, 0x70ffffff, 0x00ffffff, TileMode.CLAMP);

		paint.setShader(shader);

		// Set the Transfer mode to be porter duff and destination in

		paint.setXfermode(new PorterDuffXfermode(Mode.DST_IN));

		// Draw a rectangle using the paint with our linear gradient

		canvas.drawRect(0, height, width, bitmapWithReflection.getHeight()

		+ reflectionGap, paint);

		return bitmapWithReflection;

	}

}
